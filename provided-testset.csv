model_input,pred_correct,expected_if,predicted_if,pred_score
"def _send_from_command_queue ( self ) : <TAB> <TAB> <TAB> <TAB> while True : <TAB> <TAB> if self . isStreaming ( ) : <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> return False <TAB> <TAB> try : <TAB> <TAB> <TAB> entry = self . _command_queue . get ( block = False ) <TAB> <TAB> except queue . Empty : <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> return False <TAB> <TAB> try : <TAB> <TAB> <TAB> if isinstance ( entry , tuple ) : <TAB> <TAB> <TAB> <TAB> if not len ( entry ) == 4 : <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> continue <TAB> <TAB> <TAB> <TAB> cmd , cmd_type , callback , tags = entry <TAB> <TAB> <TAB> else : <TAB> <TAB> <TAB> <TAB> cmd = entry <TAB> <TAB> <TAB> <TAB> cmd_type = None <TAB> <TAB> <TAB> <TAB> callback = None <TAB> <TAB> <TAB> <TAB> tags = None <TAB> <TAB> <TAB> <fill-in> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> return True <TAB> <TAB> finally : <TAB> <TAB> <TAB> self . _command_queue . task_done ( )",False,"if self . _sendCommand ( cmd , cmd_type = cmd_type , on_sent = callback , tags = tags ) :",___________________,0.0
"def feed ( self , byte_str , num_bytes ) : <TAB> if self . _done : <TAB> <TAB> return <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> i = self . _need_to_skip_char_num <TAB> while i < num_bytes : <TAB> <TAB> order , char_len = self . get_order ( byte_str [ i : i + 2 ] ) <TAB> <TAB> i += char_len <TAB> <TAB> if i > num_bytes : <TAB> <TAB> <TAB> self . _need_to_skip_char_num = i - num_bytes <TAB> <TAB> <TAB> self . _last_char_order = - 1 <TAB> <TAB> else : <TAB> <TAB> <TAB> if ( order != - 1 ) and ( self . _last_char_order != - 1 ) : <TAB> <TAB> <TAB> <TAB> self . _total_rel += 1 <TAB> <TAB> <TAB> <TAB> <fill-in> <TAB> <TAB> <TAB> <TAB> <TAB> self . _done = True <TAB> <TAB> <TAB> <TAB> <TAB> break <TAB> <TAB> <TAB> <TAB> self . _rel_sample [ jp2CharContext [ self . _last_char_order ] [ order ] ] += 1 <TAB> <TAB> <TAB> self . _last_char_order = order",False,if self . _total_rel > self . MAX_REL_THRESHOLD :,___________________,0.0
"def readline ( _size = - 1 , prompt = """" , float = True , priority = 10 ) : <TAB> <TAB> <TAB> global buffer_handle , prompt_handle , suggest_handle , eof , show_suggestions <TAB> <TAB> from pwnlib . term import term_mode <TAB> if not term_mode : <TAB> <TAB> six . print_ ( prompt , end = """" , flush = True ) <TAB> <TAB> return getattr ( sys . stdin , ""buffer"" , sys . stdin ) . readline ( _size ) . rstrip ( b""\n"" ) <TAB> show_suggestions = False <TAB> eof = False <TAB> if prompt : <TAB> <TAB> prompt_handle = term . output ( prompt , float = float , priority = priority ) <TAB> else : <TAB> <TAB> prompt_handle = None <TAB> buffer_handle = term . output ( float = float , priority = priority ) <TAB> suggest_handle = None <TAB> clear ( ) <TAB> if startup_hook : <TAB> <TAB> startup_hook ( ) <TAB> try : <TAB> <TAB> while True : <TAB> <TAB> <TAB> try : <TAB> <TAB> <TAB> <TAB> try : <TAB> <TAB> <TAB> <TAB> <TAB> keymap . handle_input ( ) <TAB> <TAB> <TAB> <TAB> except EOFError : <TAB> <TAB> <TAB> <TAB> <TAB> if len ( buffer_left + buffer_right ) == 0 : <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> return b"""" <TAB> <TAB> <TAB> <TAB> if eof : <TAB> <TAB> <TAB> <TAB> <TAB> return b"""" <TAB> <TAB> <TAB> <TAB> else : <TAB> <TAB> <TAB> <TAB> <TAB> buffer = buffer_left + buffer_right <TAB> <TAB> <TAB> <TAB> <TAB> if buffer : <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> history . insert ( 0 , buffer ) <TAB> <TAB> <TAB> <TAB> <TAB> return force_to_bytes ( buffer ) + b""\n"" <TAB> <TAB> <TAB> except KeyboardInterrupt : <TAB> <TAB> <TAB> <TAB> control_c ( ) <TAB> finally : <TAB> <TAB> line = buffer_left + buffer_right + ""\n"" <TAB> <TAB> buffer_handle . update ( line ) <TAB> <TAB> buffer_handle . freeze ( ) <TAB> <TAB> buffer_handle = None <TAB> <TAB> if prompt_handle : <TAB> <TAB> <TAB> prompt_handle . freeze ( ) <TAB> <TAB> <TAB> prompt_handle = None <TAB> <TAB> <fill-in> <TAB> <TAB> <TAB> suggest_handle . freeze ( ) <TAB> <TAB> <TAB> suggest_handle = None <TAB> <TAB> if shutdown_hook : <TAB> <TAB> <TAB> shutdown_hook ( )",False,if suggest_handle :,___________________,0.0
"def process ( self ) : <TAB> """"""Process the request entity based on its Content-Type."""""" <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> h = cherrypy . serving . request . headers <TAB> if ""Content-Length"" not in h and ""Transfer-Encoding"" not in h : <TAB> <TAB> raise cherrypy . HTTPError ( 411 ) <TAB> self . fp = SizedReader ( <TAB> <TAB> self . fp , <TAB> <TAB> self . length , <TAB> <TAB> self . maxbytes , <TAB> <TAB> bufsize = self . bufsize , <TAB> <TAB> has_trailers = ""Trailer"" in h , <TAB> ) <TAB> super ( RequestBody , self ) . process ( ) <TAB> <TAB> <TAB> request_params = self . request_params <TAB> for key , value in self . params . items ( ) : <TAB> <TAB> <TAB> <TAB> if sys . version_info < ( 3 , 0 ) : <TAB> <TAB> <TAB> <fill-in> <TAB> <TAB> <TAB> <TAB> key = key . encode ( ""ISO-8859-1"" ) <TAB> <TAB> if key in request_params : <TAB> <TAB> <TAB> if not isinstance ( request_params [ key ] , list ) : <TAB> <TAB> <TAB> <TAB> request_params [ key ] = [ request_params [ key ] ] <TAB> <TAB> <TAB> request_params [ key ] . append ( value ) <TAB> <TAB> else : <TAB> <TAB> <TAB> request_params [ key ] = value",False,"if isinstance ( key , unicode ) :",___________________,0.0
"def read ( self , iprot ) : <TAB> if ( <TAB> <TAB> iprot . __class__ == TBinaryProtocol . TBinaryProtocolAccelerated <TAB> <TAB> and isinstance ( iprot . trans , TTransport . CReadableTransport ) <TAB> <TAB> and self . thrift_spec is not None <TAB> <TAB> and fastbinary is not None <TAB> ) : <TAB> <TAB> fastbinary . decode_binary ( self , iprot . trans , ( self . __class__ , self . thrift_spec ) ) <TAB> <TAB> return <TAB> iprot . readStructBegin ( ) <TAB> while True : <TAB> <TAB> ( fname , ftype , fid ) = iprot . readFieldBegin ( ) <TAB> <TAB> if ftype == TType . STOP : <TAB> <TAB> <TAB> break <TAB> <TAB> if fid == 1 : <TAB> <TAB> <TAB> if ftype == TType . STRING : <TAB> <TAB> <TAB> <TAB> self . dbname = iprot . readString ( ) <TAB> <TAB> <TAB> else : <TAB> <TAB> <TAB> <TAB> iprot . skip ( ftype ) <TAB> <TAB> elif fid == 2 : <TAB> <TAB> <TAB> if ftype == TType . STRING : <TAB> <TAB> <TAB> <TAB> self . name = iprot . readString ( ) <TAB> <TAB> <TAB> else : <TAB> <TAB> <TAB> <TAB> iprot . skip ( ftype ) <TAB> <TAB> <fill-in> <TAB> <TAB> <TAB> if ftype == TType . BOOL : <TAB> <TAB> <TAB> <TAB> self . deleteData = iprot . readBool ( ) <TAB> <TAB> <TAB> else : <TAB> <TAB> <TAB> <TAB> iprot . skip ( ftype ) <TAB> <TAB> else : <TAB> <TAB> <TAB> iprot . skip ( ftype ) <TAB> <TAB> iprot . readFieldEnd ( ) <TAB> iprot . readStructEnd ( )",False,elif fid == 3 :,___________________,0.0
"def _setup_layer ( self , trainable = False , ** kwargs ) : <TAB> """"""Constructs keras layer with relevant weights and losses."""""" <TAB> <TAB> super ( KerasLayer , self ) . __init__ ( trainable = trainable , ** kwargs ) <TAB> <TAB> if hasattr ( self . _func , ""trainable_variables"" ) : <TAB> <TAB> for v in self . _func . trainable_variables : <TAB> <TAB> <TAB> self . _add_existing_weight ( v , trainable = True ) <TAB> <TAB> trainable_variables = { id ( v ) for v in self . _func . trainable_variables } <TAB> else : <TAB> <TAB> trainable_variables = set ( ) <TAB> if hasattr ( self . _func , ""variables"" ) : <TAB> <TAB> for v in self . _func . variables : <TAB> <TAB> <TAB> <fill-in> <TAB> <TAB> <TAB> <TAB> self . _add_existing_weight ( v , trainable = False ) <TAB> <TAB> if hasattr ( self . _func , ""regularization_losses"" ) : <TAB> <TAB> for l in self . _func . regularization_losses : <TAB> <TAB> <TAB> if not callable ( l ) : <TAB> <TAB> <TAB> <TAB> raise ValueError ( <TAB> <TAB> <TAB> <TAB> <TAB> ""hub.KerasLayer(obj) expects obj.regularization_losses to be an "" <TAB> <TAB> <TAB> <TAB> <TAB> ""iterable of callables, each returning a scalar loss term."" <TAB> <TAB> <TAB> <TAB> ) <TAB> <TAB> <TAB> self . add_loss ( self . _call_loss_if_trainable ( l ) )",False,if id ( v ) not in trainable_variables :,___________________,0.0
"def bind ( self , sock , path ) : <TAB> <TAB> try : <TAB> <TAB> sock . bind ( path ) <TAB> except OSError as e : <TAB> <TAB> <fill-in> <TAB> <TAB> <TAB> self . skipTest ( <TAB> <TAB> <TAB> <TAB> ""Pathname {0!a} is too long to serve as a AF_UNIX path"" . format ( path ) <TAB> <TAB> <TAB> ) <TAB> <TAB> else : <TAB> <TAB> <TAB> raise",False,"if str ( e ) == ""AF_UNIX path too long"" :",___________________,0.0
"def findall ( self , s ) : <TAB> res = [ ] <TAB> start = 0 <TAB> while True : <TAB> <TAB> m = self . search ( s , start ) <TAB> <TAB> if not m : <TAB> <TAB> <TAB> return res <TAB> <TAB> if m . num == 1 : <TAB> <TAB> <TAB> res . append ( m . group ( 0 ) ) <TAB> <TAB> <fill-in> <TAB> <TAB> <TAB> res . append ( m . group ( 1 ) ) <TAB> <TAB> else : <TAB> <TAB> <TAB> res . append ( m . groups ( ) ) <TAB> <TAB> beg , end = m . span ( 0 ) <TAB> <TAB> start = end",False,elif m . num == 2 :,___________________,0.0
"def encode ( self ) : <TAB> e = self . expr <TAB> if e in self . reg_info . expr : <TAB> <TAB> self . parent . a_d . value = 0 <TAB> <TAB> self . value = self . reg_info . expr . index ( e ) <TAB> elif isinstance ( e , ExprMem ) : <TAB> <TAB> if isinstance ( e . ptr , ExprId ) : <TAB> <TAB> <TAB> r , i = e . ptr , ExprInt ( 0 , 16 ) <TAB> <TAB> <fill-in> <TAB> <TAB> <TAB> r , i = e . ptr . args [ 0 ] , e . ptr . args [ 1 ] <TAB> <TAB> elif isinstance ( e . ptr , ExprInt ) : <TAB> <TAB> <TAB> r , i = SR , e . ptr <TAB> <TAB> else : <TAB> <TAB> <TAB> raise NotImplementedError ( ""unknown instance e.arg = %s"" % type ( e . ptr ) ) <TAB> <TAB> self . parent . a_d . value = 1 <TAB> <TAB> self . value = self . reg_info . expr . index ( r ) <TAB> <TAB> self . parent . off_d . value = int ( i ) <TAB> else : <TAB> <TAB> raise NotImplementedError ( ""unknown instance e = %s"" % type ( e ) ) <TAB> return True",False,"elif isinstance ( e . ptr , ExprOp ) :",___________________,0.0
"def resolve_account ( self , account_name ) : <TAB> account = None <TAB> if isinstance ( account_name , ( int , float ) ) : <TAB> <TAB> acc_id = int ( account_name ) <TAB> <TAB> self . log . debug ( ""Treating account name as ID: %s"" , acc_id ) <TAB> <TAB> account = self . user . accounts ( ident = acc_id ) . first ( ) <TAB> <TAB> <fill-in> <TAB> <TAB> <TAB> raise TaurusConfigError ( ""BlazeMeter account not found by ID: %s"" % acc_id ) <TAB> elif account_name : <TAB> <TAB> account = self . user . accounts ( name = account_name ) . first ( ) <TAB> <TAB> <fill-in> <TAB> <TAB> <TAB> raise TaurusConfigError ( <TAB> <TAB> <TAB> <TAB> ""BlazeMeter account not found by name: %s"" % account_name <TAB> <TAB> <TAB> ) <TAB> if account : <TAB> <TAB> return account <TAB> self . user . fetch ( ) <TAB> account = self . user . accounts ( ident = self . user [ ""defaultProject"" ] [ ""accountId"" ] ) . first ( ) <TAB> self . log . debug ( ""Using default account: %s"" , account ) <TAB> return account",False,if not account :,___________________,0.0
"def read_embeddings ( file_enc , skip_lines = 0 , filter_set = None ) : <TAB> embs = dict ( ) <TAB> total_vectors_in_file = 0 <TAB> with open ( file_enc , ""rb"" ) as f : <TAB> <TAB> for i , line in enumerate ( f ) : <TAB> <TAB> <TAB> if i < skip_lines : <TAB> <TAB> <TAB> <TAB> continue <TAB> <TAB> <TAB> if not line : <TAB> <TAB> <TAB> <TAB> break <TAB> <TAB> <TAB> <fill-in> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> continue <TAB> <TAB> <TAB> l_split = line . decode ( ""utf8"" ) . strip ( ) . split ( "" "" ) <TAB> <TAB> <TAB> if len ( l_split ) == 2 : <TAB> <TAB> <TAB> <TAB> continue <TAB> <TAB> <TAB> total_vectors_in_file += 1 <TAB> <TAB> <TAB> if filter_set is not None and l_split [ 0 ] not in filter_set : <TAB> <TAB> <TAB> <TAB> continue <TAB> <TAB> <TAB> embs [ l_split [ 0 ] ] = [ float ( em ) for em in l_split [ 1 : ] ] <TAB> return embs , total_vectors_in_file",False,if len ( line ) == 0 :,___________________,0.0
"def config_dict ( filename ) : <TAB> """"""Convert content of config-file into dictionary."""""" <TAB> with open ( filename , ""r"" ) as f : <TAB> <TAB> cfglines = f . readlines ( ) <TAB> cfgdict = { } <TAB> for line in cfglines : <TAB> <TAB> line = line . strip ( ) <TAB> <TAB> <fill-in> <TAB> <TAB> <TAB> continue <TAB> <TAB> try : <TAB> <TAB> <TAB> key , value = line . split ( ""="" ) <TAB> <TAB> except ValueError : <TAB> <TAB> <TAB> print ( ""Bad line in config-file %s:\n%s"" % ( filename , line ) ) <TAB> <TAB> <TAB> continue <TAB> <TAB> key = key . strip ( ) <TAB> <TAB> value = value . strip ( ) <TAB> <TAB> if value in [ ""True"" , ""False"" , ""None"" , ""''"" , '""""' ] : <TAB> <TAB> <TAB> value = eval ( value ) <TAB> <TAB> else : <TAB> <TAB> <TAB> try : <TAB> <TAB> <TAB> <TAB> if ""."" in value : <TAB> <TAB> <TAB> <TAB> <TAB> value = float ( value ) <TAB> <TAB> <TAB> <TAB> else : <TAB> <TAB> <TAB> <TAB> <TAB> value = int ( value ) <TAB> <TAB> <TAB> except ValueError : <TAB> <TAB> <TAB> <TAB> pass <TAB> <TAB> cfgdict [ key ] = value <TAB> return cfgdict",False,"if not line or line . startswith ( ""#"" ) :",___________________,0.0
"def gen_colinfo ( data ) : <TAB> colinfo = { ""pid"" : 0 } <TAB> for pid in data : <TAB> <TAB> pid_len = len ( str ( pid ) ) <TAB> <TAB> if colinfo [ ""pid"" ] < pid_len : <TAB> <TAB> <TAB> colinfo [ ""pid"" ] = pid_len <TAB> <TAB> for column in data [ pid ] : <TAB> <TAB> <TAB> <fill-in> <TAB> <TAB> <TAB> <TAB> colinfo [ column ] = 4 <TAB> <TAB> <TAB> <TAB> continue <TAB> <TAB> <TAB> if type ( data [ pid ] [ column ] ) not in ( str , unicode , int , float ) : <TAB> <TAB> <TAB> <TAB> continue <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> if type ( data [ pid ] [ column ] ) == unicode : <TAB> <TAB> <TAB> <TAB> data [ pid ] [ column ] = data [ pid ] [ column ] . encode ( ""utf8"" , ""replace"" ) <TAB> <TAB> <TAB> pid_len = len ( str ( data [ pid ] [ column ] ) ) <TAB> <TAB> <TAB> if column not in colinfo : <TAB> <TAB> <TAB> <TAB> colinfo [ column ] = pid_len <TAB> <TAB> <TAB> else : <TAB> <TAB> <TAB> <TAB> if colinfo [ column ] < pid_len : <TAB> <TAB> <TAB> <TAB> <TAB> colinfo [ column ] = pid_len <TAB> return colinfo",False,"if ""_percent"" in column :",___________________,0.0
"def readline ( _size = - 1 , prompt = """" , float = True , priority = 10 ) : <TAB> <TAB> <TAB> global buffer_handle , prompt_handle , suggest_handle , eof , show_suggestions <TAB> <TAB> from pwnlib . term import term_mode <TAB> if not term_mode : <TAB> <TAB> six . print_ ( prompt , end = """" , flush = True ) <TAB> <TAB> return getattr ( sys . stdin , ""buffer"" , sys . stdin ) . readline ( _size ) . rstrip ( b""\n"" ) <TAB> show_suggestions = False <TAB> eof = False <TAB> if prompt : <TAB> <TAB> prompt_handle = term . output ( prompt , float = float , priority = priority ) <TAB> else : <TAB> <TAB> prompt_handle = None <TAB> buffer_handle = term . output ( float = float , priority = priority ) <TAB> suggest_handle = None <TAB> clear ( ) <TAB> if startup_hook : <TAB> <TAB> startup_hook ( ) <TAB> try : <TAB> <TAB> while True : <TAB> <TAB> <TAB> try : <TAB> <TAB> <TAB> <TAB> try : <TAB> <TAB> <TAB> <TAB> <TAB> keymap . handle_input ( ) <TAB> <TAB> <TAB> <TAB> except EOFError : <TAB> <TAB> <TAB> <TAB> <TAB> if len ( buffer_left + buffer_right ) == 0 : <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> return b"""" <TAB> <TAB> <TAB> <TAB> if eof : <TAB> <TAB> <TAB> <TAB> <TAB> return b"""" <TAB> <TAB> <TAB> <TAB> else : <TAB> <TAB> <TAB> <TAB> <TAB> buffer = buffer_left + buffer_right <TAB> <TAB> <TAB> <TAB> <TAB> <fill-in> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> history . insert ( 0 , buffer ) <TAB> <TAB> <TAB> <TAB> <TAB> return force_to_bytes ( buffer ) + b""\n"" <TAB> <TAB> <TAB> except KeyboardInterrupt : <TAB> <TAB> <TAB> <TAB> control_c ( ) <TAB> finally : <TAB> <TAB> line = buffer_left + buffer_right + ""\n"" <TAB> <TAB> buffer_handle . update ( line ) <TAB> <TAB> buffer_handle . freeze ( ) <TAB> <TAB> buffer_handle = None <TAB> <TAB> if prompt_handle : <TAB> <TAB> <TAB> prompt_handle . freeze ( ) <TAB> <TAB> <TAB> prompt_handle = None <TAB> <TAB> if suggest_handle : <TAB> <TAB> <TAB> suggest_handle . freeze ( ) <TAB> <TAB> <TAB> suggest_handle = None <TAB> <TAB> if shutdown_hook : <TAB> <TAB> <TAB> shutdown_hook ( )",False,if buffer :,___________________,0.0
"def init ( self ) : <TAB> """"""Initialize a module from the database and validate"""""" <TAB> self . __item = None <TAB> self . __baseItem = None <TAB> self . __charge = None <TAB> self . __mutaplasmid = None <TAB> <TAB> self . __slot = self . dummySlot <TAB> if self . itemID : <TAB> <TAB> self . __item = eos . db . getItem ( self . itemID ) <TAB> <TAB> if self . __item is None : <TAB> <TAB> <TAB> pyfalog . error ( ""Item (id: {0}) does not exist"" , self . itemID ) <TAB> <TAB> <TAB> return <TAB> if self . baseItemID : <TAB> <TAB> self . __item = eos . db . getItemWithBaseItemAttribute ( self . itemID , self . baseItemID ) <TAB> <TAB> self . __baseItem = eos . db . getItem ( self . baseItemID ) <TAB> <TAB> self . __mutaplasmid = eos . db . getMutaplasmid ( self . mutaplasmidID ) <TAB> <TAB> <fill-in> <TAB> <TAB> <TAB> pyfalog . error ( ""Base Item (id: {0}) does not exist"" , self . itemID ) <TAB> <TAB> <TAB> return <TAB> if self . isInvalid : <TAB> <TAB> pyfalog . error ( ""Item (id: {0}) is not a Module"" , self . itemID ) <TAB> <TAB> return <TAB> if self . chargeID : <TAB> <TAB> self . __charge = eos . db . getItem ( self . chargeID ) <TAB> self . build ( )",False,if self . __baseItem is None :,___________________,0.0
"def _get_enclosing_context_level ( child_context , name ) : <TAB> <TAB> <TAB> if name in child_context . local_vars : <TAB> <TAB> return None <TAB> else : <TAB> <TAB> level = 0 <TAB> <TAB> for context in child_context . outer_contexts [ : : - 1 ] : <TAB> <TAB> <TAB> level += 1 <TAB> <TAB> <TAB> <fill-in> <TAB> <TAB> <TAB> <TAB> return level <TAB> return None",False,if name in context . local_vars and context . local_vars [ name ] is not None :,___________________,0.0
"def test_object_role_JT_attach ( <TAB> rando , <TAB> job_template , <TAB> workflow_job_template , <TAB> inventory_source , <TAB> notification_template , <TAB> res_role , <TAB> expect , ) : <TAB> nt_organization = Organization . objects . create ( <TAB> <TAB> name = ""organization just for the notification template"" <TAB> ) <TAB> nt_organization . notification_admin_role . members . add ( rando ) <TAB> notification_template . organization = nt_organization <TAB> notification_template . save ( ) <TAB> kwargs = dict ( <TAB> <TAB> sub_obj = notification_template , <TAB> <TAB> relationship = ""notification_templates_success"" , <TAB> <TAB> data = { ""id"" : notification_template . id } , <TAB> ) <TAB> permissions = { } <TAB> expected_permissions = { } <TAB> for resource in ( job_template , workflow_job_template , inventory_source ) : <TAB> <TAB> permission_resource = resource <TAB> <TAB> if resource == inventory_source : <TAB> <TAB> <TAB> permission_resource = inventory_source . inventory <TAB> <TAB> model_name = resource . __class__ . __name__ <TAB> <TAB> <fill-in> <TAB> <TAB> <TAB> if res_role is not None : <TAB> <TAB> <TAB> <TAB> getattr ( permission_resource , res_role ) . members . add ( rando ) <TAB> <TAB> <TAB> permissions [ model_name ] = rando . can_access ( <TAB> <TAB> <TAB> <TAB> resource . __class__ , ""attach"" , resource , ** kwargs <TAB> <TAB> <TAB> ) <TAB> <TAB> <TAB> expected_permissions [ model_name ] = expect <TAB> <TAB> else : <TAB> <TAB> <TAB> permissions [ model_name ] = None <TAB> <TAB> <TAB> expected_permissions [ model_name ] = None <TAB> assert permissions == expected_permissions",False,"if res_role is None or hasattr ( permission_resource , res_role ) :",___________________,0.0
"def run ( self ) : <TAB> while True : <TAB> <TAB> if not self . initialized : <TAB> <TAB> <TAB> try : <TAB> <TAB> <TAB> <TAB> with Client ( ) as c : <TAB> <TAB> <TAB> <TAB> <TAB> self . disks = c . call ( ""disk.disks_for_temperature_monitoring"" ) <TAB> <TAB> <TAB> <TAB> <TAB> self . powermode = c . call ( ""smart.config"" ) [ ""powermode"" ] <TAB> <TAB> <TAB> except Exception as e : <TAB> <TAB> <TAB> <TAB> print ( f""Failed to query disks for temperature monitoring: {e!r}"" ) <TAB> <TAB> <TAB> else : <TAB> <TAB> <TAB> <TAB> self . initialized = True <TAB> <TAB> if not self . initialized : <TAB> <TAB> <TAB> time . sleep ( self . interval ) <TAB> <TAB> <TAB> continue <TAB> <TAB> <fill-in> <TAB> <TAB> <TAB> return <TAB> <TAB> try : <TAB> <TAB> <TAB> with Client ( ) as c : <TAB> <TAB> <TAB> <TAB> self . temperatures = { <TAB> <TAB> <TAB> <TAB> <TAB> disk : temperature * 1000 <TAB> <TAB> <TAB> <TAB> <TAB> for disk , temperature in c . call ( <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ""disk.temperatures"" , self . disks , self . powermode <TAB> <TAB> <TAB> <TAB> <TAB> ) . items ( ) <TAB> <TAB> <TAB> <TAB> <TAB> if temperature is not None <TAB> <TAB> <TAB> <TAB> } <TAB> <TAB> except Exception as e : <TAB> <TAB> <TAB> print ( f""Failed to collect disks temperatures: {e!r}"" ) <TAB> <TAB> <TAB> self . temperatures = { } <TAB> <TAB> time . sleep ( self . interval )",False,if not self . disks :,___________________,0.0
"def _performance_by_month ( user_id , months = 12 , end_month = None , end_year = None ) : <TAB> monthly_data = OrderedDict ( ) <TAB> now = datetime . now ( ) <TAB> if not end_month : <TAB> <TAB> end_month = now . month <TAB> if not end_year : <TAB> <TAB> end_year = now . year <TAB> end_time = time . mktime ( ( end_year , end_month + 1 , 1 , 0 , 0 , 0 , 0 , 0 , - 1 ) ) <TAB> start_time = time . mktime ( ( end_year , end_month + 1 - months , 1 , 0 , 0 , 0 , 0 , 0 , - 1 ) ) <TAB> sql = PerformanceGraph . objects . filter_raw ( <TAB> <TAB> ""log_activity.created >="" , date . fromtimestamp ( start_time ) . isoformat ( ) <TAB> ) . filter_raw ( ""log_activity.created <"" , date . fromtimestamp ( end_time ) . isoformat ( ) ) <TAB> for row in sql . all ( ) : <TAB> <TAB> label = row . approval_created . isoformat ( ) [ : 7 ] <TAB> <TAB> <fill-in> <TAB> <TAB> <TAB> xaxis = row . approval_created . strftime ( ""%b %Y"" ) <TAB> <TAB> <TAB> monthly_data [ label ] = dict ( teamcount = 0 , usercount = 0 , teamamt = 0 , label = xaxis ) <TAB> <TAB> monthly_data [ label ] [ ""teamamt"" ] = monthly_data [ label ] [ ""teamamt"" ] + 1 <TAB> <TAB> monthly_data_count = monthly_data [ label ] [ ""teamcount"" ] <TAB> <TAB> monthly_data [ label ] [ ""teamcount"" ] = monthly_data_count + row . total <TAB> <TAB> if row . user_id == user_id : <TAB> <TAB> <TAB> user_count = monthly_data [ label ] [ ""usercount"" ] <TAB> <TAB> <TAB> monthly_data [ label ] [ ""usercount"" ] = user_count + row . total <TAB> <TAB> for i , vals in monthly_data . items ( ) : <TAB> <TAB> average = round ( vals [ ""teamcount"" ] / float ( vals [ ""teamamt"" ] ) , 1 ) <TAB> <TAB> monthly_data [ i ] [ ""teamavg"" ] = str ( average ) <TAB> return monthly_data",False,if label not in monthly_data :,___________________,0.0
"def get_action ( self , values , option_string ) : <TAB> try : <TAB> <TAB> properties = defaultdict ( list ) <TAB> <TAB> for ( k , v ) in ( x . split ( ""="" , 1 ) for x in values ) : <TAB> <TAB> <TAB> properties [ k ] . append ( v ) <TAB> <TAB> properties = dict ( properties ) <TAB> except ValueError : <TAB> <TAB> raise CLIError ( ""usage error: {} [KEY=VALUE ...]"" . format ( option_string ) ) <TAB> d = { } <TAB> for k in properties : <TAB> <TAB> kl = k . lower ( ) <TAB> <TAB> v = properties [ k ] <TAB> <TAB> if kl == ""first-name"" : <TAB> <TAB> <TAB> d [ ""first_name"" ] = v [ 0 ] <TAB> <TAB> <fill-in> <TAB> <TAB> <TAB> d [ ""last_name"" ] = v [ 0 ] <TAB> <TAB> elif kl == ""company-name"" : <TAB> <TAB> <TAB> d [ ""company_name"" ] = v [ 0 ] <TAB> <TAB> elif kl == ""address-line1"" : <TAB> <TAB> <TAB> d [ ""address_line1"" ] = v [ 0 ] <TAB> <TAB> elif kl == ""address-line2"" : <TAB> <TAB> <TAB> d [ ""address_line2"" ] = v [ 0 ] <TAB> <TAB> elif kl == ""address-line3"" : <TAB> <TAB> <TAB> d [ ""address_line3"" ] = v [ 0 ] <TAB> <TAB> elif kl == ""city"" : <TAB> <TAB> <TAB> d [ ""city"" ] = v [ 0 ] <TAB> <TAB> elif kl == ""district"" : <TAB> <TAB> <TAB> d [ ""district"" ] = v [ 0 ] <TAB> <TAB> elif kl == ""region"" : <TAB> <TAB> <TAB> d [ ""region"" ] = v [ 0 ] <TAB> <TAB> elif kl == ""country"" : <TAB> <TAB> <TAB> d [ ""country"" ] = v [ 0 ] <TAB> <TAB> elif kl == ""postal-code"" : <TAB> <TAB> <TAB> d [ ""postal_code"" ] = v [ 0 ] <TAB> <TAB> elif kl == ""email"" : <TAB> <TAB> <TAB> d [ ""email"" ] = v [ 0 ] <TAB> <TAB> elif kl == ""phone-number"" : <TAB> <TAB> <TAB> d [ ""phone_number"" ] = v [ 0 ] <TAB> return d",False,"elif kl == ""last-name"" :",___________________,0.0
"def calcPolygonRect ( pointArray ) : <TAB> """"""receives a point list and returns the rect that contains them as a tupple -> tuple left, top, right, bottom"""""" <TAB> <TAB> l , t , r , b = 10000000 , 10000000 , - 10000000 , - 10000000 <TAB> <TAB> <TAB> <TAB> <TAB> for n in pointArray : <TAB> <TAB> <fill-in> <TAB> <TAB> <TAB> l = n [ 0 ] <TAB> <TAB> if n [ 0 ] > r : <TAB> <TAB> <TAB> r = n [ 0 ] <TAB> <TAB> if n [ 1 ] < t : <TAB> <TAB> <TAB> t = n [ 1 ] <TAB> <TAB> if n [ 1 ] > b : <TAB> <TAB> <TAB> b = n [ 1 ] <TAB> return l , t , r , b",False,if n [ 0 ] < l :,___________________,0.0
"def render ( self , context ) : <TAB> bits = [ ] <TAB> for node in self : <TAB> <TAB> <fill-in> <TAB> <TAB> <TAB> bit = self . render_node ( node , context ) <TAB> <TAB> else : <TAB> <TAB> <TAB> bit = node <TAB> <TAB> bits . append ( force_unicode ( bit ) ) <TAB> return mark_safe ( u"""" . join ( bits ) )",False,"if isinstance ( node , Node ) :",___________________,0.0
"def _cache_db_tables_iterator ( tables , cache_alias , db_alias ) : <TAB> no_tables = not tables <TAB> cache_aliases = settings . CACHES if cache_alias is None else ( cache_alias , ) <TAB> db_aliases = settings . DATABASES if db_alias is None else ( db_alias , ) <TAB> for db_alias in db_aliases : <TAB> <TAB> if no_tables : <TAB> <TAB> <TAB> tables = connections [ db_alias ] . introspection . table_names ( ) <TAB> <TAB> <fill-in> <TAB> <TAB> <TAB> for cache_alias in cache_aliases : <TAB> <TAB> <TAB> <TAB> yield cache_alias , db_alias , tables",False,if tables :,___________________,0.0
"def semanticTags ( self , semanticTags ) : <TAB> if semanticTags is None : <TAB> <TAB> self . __semanticTags = OrderedDict ( ) <TAB> <TAB> for key , value in list ( semanticTags . items ( ) ) : <TAB> <TAB> if not isinstance ( key , int ) : <TAB> <TAB> <TAB> raise TypeError ( ""At least one key is not a valid int position"" ) <TAB> <TAB> if not isinstance ( value , list ) : <TAB> <TAB> <TAB> raise TypeError ( <TAB> <TAB> <TAB> <TAB> ""At least one value of the provided dict is not a list of string"" <TAB> <TAB> <TAB> ) <TAB> <TAB> for x in value : <TAB> <TAB> <TAB> <fill-in> <TAB> <TAB> <TAB> <TAB> raise TypeError ( <TAB> <TAB> <TAB> <TAB> <TAB> ""At least one value of the provided dict is not a list of string"" <TAB> <TAB> <TAB> <TAB> ) <TAB> self . __semanticTags = semanticTags",False,"if not isinstance ( x , str ) :",___________________,0.0
"def __init__ ( <TAB> self , backbone , refiner = None , train_cfg = None , test_cfg = None , pretrained = None ) : <TAB> super ( BaseMattor , self ) . __init__ ( ) <TAB> self . train_cfg = train_cfg if train_cfg is not None else ConfigDict ( ) <TAB> self . test_cfg = test_cfg if test_cfg is not None else ConfigDict ( ) <TAB> self . backbone = build_backbone ( backbone ) <TAB> <TAB> if refiner is None : <TAB> <TAB> self . train_cfg [ ""train_refiner"" ] = False <TAB> <TAB> self . test_cfg [ ""refine"" ] = False <TAB> else : <TAB> <TAB> self . refiner = build_component ( refiner ) <TAB> <TAB> if train_cfg is not None : <TAB> <TAB> assert hasattr ( self . train_cfg , ""train_refiner"" ) <TAB> <TAB> assert hasattr ( self . test_cfg , ""refine"" ) <TAB> <TAB> if self . test_cfg . refine and not self . train_cfg . train_refiner : <TAB> <TAB> <TAB> print_log ( <TAB> <TAB> <TAB> <TAB> ""You are not training the refiner, but it is used for "" <TAB> <TAB> <TAB> <TAB> ""model forwarding."" , <TAB> <TAB> <TAB> <TAB> ""root"" , <TAB> <TAB> <TAB> <TAB> logging . WARNING , <TAB> <TAB> <TAB> ) <TAB> <TAB> if not self . train_cfg . train_backbone : <TAB> <TAB> <TAB> self . freeze_backbone ( ) <TAB> <TAB> if not hasattr ( self . test_cfg , ""metrics"" ) : <TAB> <TAB> raise KeyError ( 'Missing key ""metrics"" in test_cfg' ) <TAB> elif mmcv . is_list_of ( self . test_cfg . metrics , str ) : <TAB> <TAB> for metric in self . test_cfg . metrics : <TAB> <TAB> <TAB> <fill-in> <TAB> <TAB> <TAB> <TAB> raise KeyError ( f""metric {metric} is not supported"" ) <TAB> elif self . test_cfg . metrics is not None : <TAB> <TAB> raise TypeError ( ""metrics must be None or a list of str"" ) <TAB> self . init_weights ( pretrained )",False,if metric not in self . allowed_metrics :,___________________,0.0
"def do ( tag ) : <TAB> name = getattr ( tag , ""name"" , None ) <TAB> <TAB> <TAB> name = name . lower ( ) if name is not None else """" <TAB> if not name : <TAB> <TAB> text ( tag ) <TAB> elif name == ""h1"" : <TAB> <TAB> macro ( "".SH"" , _force_string ( tag , tag ) . upper ( ) ) <TAB> <TAB> w . started = True <TAB> elif name == ""h2"" : <TAB> <TAB> macro ( "".SS"" , _force_string ( tag , tag ) ) <TAB> <TAB> w . started = True <TAB> elif name . startswith ( ""h"" ) and len ( name ) == 2 : <TAB> <TAB> raise ValueError ( ""%r invalid - man page headers must be h1 or h2"" % name ) <TAB> elif name == ""pre"" : <TAB> <TAB> t = _force_string ( tag . code , tag . code ) <TAB> <TAB> <fill-in> <TAB> <TAB> <TAB> macro ( "".RS"" , ""+4n"" ) <TAB> <TAB> <TAB> macro ( "".nf"" ) <TAB> <TAB> <TAB> w . write ( _clean ( t ) . rstrip ( ) ) <TAB> <TAB> <TAB> macro ( "".fi"" ) <TAB> <TAB> <TAB> macro ( "".RE"" ) <TAB> <TAB> <TAB> w . end_para ( ) <TAB> elif name == ""p"" or name == ""br"" : <TAB> <TAB> g = re . match ( re . compile ( r""([^\n]*)\n *: +(.*)"" , re . S ) , str ( tag ) ) <TAB> <TAB> if g : <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> do_definition ( tag ) <TAB> <TAB> else : <TAB> <TAB> <TAB> text ( tag ) <TAB> <TAB> <TAB> w . end_para ( ) <TAB> elif name == ""ul"" : <TAB> <TAB> do_list ( tag ) <TAB> else : <TAB> <TAB> raise ValueError ( ""non-man-compatible html tag %r"" % name )",False,if t . strip ( ) :,___________________,0.0
"def upgrade_state_dict_named ( self , state_dict , name ) : <TAB> """"""Upgrade a (possibly old) state dict for new versions of fairseq."""""" <TAB> if isinstance ( self . embed_positions , SinusoidalPositionalEmbedding ) : <TAB> <TAB> weights_key = ""{}.embed_positions.weights"" . format ( name ) <TAB> <TAB> <fill-in> <TAB> <TAB> <TAB> del state_dict [ weights_key ] <TAB> <TAB> state_dict [ ""{}.embed_positions._float_tensor"" . format ( name ) ] = torch . FloatTensor ( <TAB> <TAB> <TAB> 1 <TAB> <TAB> ) <TAB> for i in range ( len ( self . layers ) ) : <TAB> <TAB> <TAB> <TAB> layer_norm_map = { <TAB> <TAB> <TAB> ""0"" : ""self_attn_layer_norm"" , <TAB> <TAB> <TAB> ""1"" : ""encoder_attn_layer_norm"" , <TAB> <TAB> <TAB> ""2"" : ""final_layer_norm"" , <TAB> <TAB> } <TAB> <TAB> for old , new in layer_norm_map . items ( ) : <TAB> <TAB> <TAB> for m in ( ""weight"" , ""bias"" ) : <TAB> <TAB> <TAB> <TAB> k = ""{}.layers.{}.layer_norms.{}.{}"" . format ( name , i , old , m ) <TAB> <TAB> <TAB> <TAB> if k in state_dict : <TAB> <TAB> <TAB> <TAB> <TAB> state_dict [ <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> ""{}.layers.{}.{}.{}"" . format ( name , i , new , m ) <TAB> <TAB> <TAB> <TAB> <TAB> ] = state_dict [ k ] <TAB> <TAB> <TAB> <TAB> <TAB> del state_dict [ k ] <TAB> version_key = ""{}.version"" . format ( name ) <TAB> if utils . item ( state_dict . get ( version_key , torch . Tensor ( [ 1 ] ) ) [ 0 ] ) <= 2 : <TAB> <TAB> <TAB> <TAB> self . layer_norm = None <TAB> <TAB> self . normalize = False <TAB> <TAB> state_dict [ version_key ] = torch . Tensor ( [ 1 ] ) <TAB> return state_dict",False,if weights_key in state_dict :,___________________,0.0
"def replacefunc ( elt ) : <TAB> text = elt . attrib [ ""href"" ] <TAB> if link_type ( text ) != ""page"" : <TAB> <TAB> raise zim . formats . VisitorSkip <TAB> href = HRef . new_from_wiki_link ( text ) <TAB> if href . rel == HREF_REL_RELATIVE : <TAB> <TAB> raise zim . formats . VisitorSkip <TAB> elif href . rel == HREF_REL_ABSOLUTE : <TAB> <TAB> oldtarget = self . pages . resolve_link ( page , href ) <TAB> <TAB> <fill-in> <TAB> <TAB> <TAB> return self . _update_link_tag ( elt , page , newroot , href ) <TAB> <TAB> elif oldtarget . ischild ( oldroot ) : <TAB> <TAB> <TAB> newtarget = newroot + oldtarget . relname ( oldroot ) <TAB> <TAB> <TAB> return self . _update_link_tag ( elt , page , newtarget , href ) <TAB> <TAB> else : <TAB> <TAB> <TAB> raise zim . formats . VisitorSkip <TAB> else : <TAB> <TAB> assert href . rel == HREF_REL_FLOATING <TAB> <TAB> newtarget = self . pages . resolve_link ( page , href ) <TAB> <TAB> oldtarget = self . pages . resolve_link ( oldpath , href ) <TAB> <TAB> <fill-in> <TAB> <TAB> <TAB> return self . _update_link_tag ( elt , page , newroot , href ) <TAB> <TAB> elif oldtarget . ischild ( oldroot ) : <TAB> <TAB> <TAB> oldanchor = self . pages . resolve_link ( <TAB> <TAB> <TAB> <TAB> oldpath , HRef ( HREF_REL_FLOATING , href . parts ( ) [ 0 ] ) <TAB> <TAB> <TAB> ) <TAB> <TAB> <TAB> if oldanchor . ischild ( oldroot ) : <TAB> <TAB> <TAB> <TAB> raise zim . formats . VisitorSkip <TAB> <TAB> <TAB> else : <TAB> <TAB> <TAB> <TAB> newtarget = newroot + oldtarget . relname ( oldroot ) <TAB> <TAB> <TAB> <TAB> return self . _update_link_tag ( elt , page , newtarget , href ) <TAB> <TAB> elif newtarget != oldtarget : <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> return self . _update_link_tag ( elt , page , oldtarget , href ) <TAB> <TAB> else : <TAB> <TAB> <TAB> raise zim . formats . VisitorSkip",False,if oldtarget == oldroot :,___________________,0.0
"def put_blank_line ( self , trace , count = 1 ) : <TAB> count -= self . blank_line_count <TAB> while count > ZERO : <TAB> <TAB> self . put ( BLANK_LINE ) <TAB> <TAB> self . put ( self . newline ) <TAB> <TAB> <fill-in> <TAB> <TAB> <TAB> self . put ( ""blank(%s)"" % str ( trace ) ) <TAB> <TAB> self . blank_line_count += 1 <TAB> <TAB> count -= 1 <TAB> return self",False,if DEBUG :,___________________,0.0
"def test ( self , setting ) : <TAB> self . logger . debug ( ""Testing connection to snzbget"" ) <TAB> rpc = self . get_rpc ( <TAB> <TAB> setting . host , <TAB> <TAB> setting . ssl , <TAB> <TAB> setting . port , <TAB> <TAB> setting . username , <TAB> <TAB> urllib . quote ( setting . password . encode ( ""utf-8"" ) ) , <TAB> ) <TAB> try : <TAB> <TAB> if rpc . writelog ( ""INFO"" , ""NZB Hydra connected to test connection"" ) : <TAB> <TAB> <TAB> version = rpc . version ( ) <TAB> <TAB> <TAB> <TAB> <TAB> <TAB> if int ( version [ : 2 ] ) < 13 : <TAB> <TAB> <TAB> <TAB> self . logger . error ( ""NZBGet needs to be version 13 or higher"" ) <TAB> <TAB> <TAB> <TAB> return False , ""NZBGet needs to be version 13 or higher"" <TAB> <TAB> <TAB> self . logger . info ( ""Connection test to NZBGet successful"" ) <TAB> <TAB> else : <TAB> <TAB> <TAB> self . logger . info ( <TAB> <TAB> <TAB> <TAB> ""Successfully connected to NZBGet, but unable to send a message"" <TAB> <TAB> <TAB> ) <TAB> except socket . error : <TAB> <TAB> self . logger . error ( <TAB> <TAB> <TAB> ""NZBGet is not responding. Please ensure that NZBGet is running and host setting is correct."" <TAB> <TAB> ) <TAB> <TAB> return False , ""NZBGet is not responding under this address, scheme and port"" <TAB> except xmlrpc . client . ProtocolError as e : <TAB> <TAB> <fill-in> <TAB> <TAB> <TAB> self . logger . error ( ""Wrong credentials"" ) <TAB> <TAB> <TAB> return False , ""Wrong credentials"" <TAB> <TAB> else : <TAB> <TAB> <TAB> self . logger . error ( ""Protocol error: %s"" , e ) <TAB> <TAB> return False , str ( e ) <TAB> except Exception as e : <TAB> <TAB> self . logger . exception ( ""Unknown error while communicating with NZBGet"" ) <TAB> <TAB> return False , str ( e ) <TAB> return True , """"",False,if e . errcode == 401 :,___________________,0.0
